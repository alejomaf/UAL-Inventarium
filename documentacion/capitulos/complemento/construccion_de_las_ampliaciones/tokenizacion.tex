\section{Tokenización}

La utilización de tokens durante el desarrollo de APIs ha incrementado a lo largo de los últimos años. Estos tokens permiten aislar de esa capa de seguridad de implementación extra a la que te antes te veías sometido por hacer aplicaciones que gestionasen sus propias consultas con la base de datos.
\\A medida que iba realizando la construcción de la aplicación pensaba en esta implementación de seguridad.
\\En un principio lo que hice fue almacenar los datos del usuario y la contraseña de este en caché. Cada vez que se mandaba una consulta se utilizaban los datos en caché del usuario para analizarla y proceder a un sistema de autenticación.
\\Este proceso de autenticación también iba ligado a una ``API'' podríamos llegar a considerarlo aunque nunca llegó a ser tan potente ni bien planificada como la actual.
\\El proceso de generación de tokens desde un entorno del cliente resulta un proceso algo tedioso y que nunca hay que realizar. Por suerte, para el entorno del servidor de nuestra API había algunas herramientas que nos podrían ayudar.

\subsection{Generación del token}
La generación de tokens siempre es un proceso que me ha plasmado dudas, ya que en un principio pensaba que el almacenamiento de este realizaba sobre la base de datos en vez de en el propio servidor. Por suerte me encontré con el plugin ideal el cual se encuentra en el Node Package Manager, jwt-simple.
\\Gracias a este plugin podría realizar el codificado y decodificado de un plugin generado cada vez que un usuario iniciara sesión.
\\Dentro de las fases del codificado de este token necesitamos pasarle como parámetros unas fechas que será la duración que tendrán de validez estos ``simbólicos'' (traducción de token al español).
\\El proceso de codificado de nuestro token se realizará dentro de nuestro inicio de sesión. Quedando de la siguiente forma:

\begin{verbatim}
    const createToken = (usuario) => {
        let payload = {
            userId: usuario.idUsuario,
            createdAt: moment().unix(),
            expiresAt: moment().add(1, 'day').unix()
        }
        return jwt.encode(payload, process.env.TOKEN_KEY);
    };
\end{verbatim}

Esta función se ejecuta cuando hemos podido corroborar que el usuario ha iniciado sesión correctamente y sin problemas.
\\Lo que codificamos dentro de nuestra variable TOKEN\_KEY ubicada en el archivo .env es un payload que cogerá como parámetros: el id del usuario, el momento en el que se ha logueado y el momento donde expirará su sesión.

Teniendo ya nuestro token generado tenemos que de alguna forma hacer que cada vez que quiera hacer una consulta el usuario pueda hacerlo con su token.

\begin{tcolorbox}
    [colback=green!5!white,colframe=green!75!black,fonttitle=\bfseries,title=¿Por qué almacenamos la id del usuario en nuestro payload?]
    La id del usuario se almacena porque cada vez que queramos acceder a una consulta siendo clientes podremos meter en nuestra soicitud ese nuevo campo. Esta acción la realizaremos siempre por lo que nos aseguramos disponer de los datos del usuario en cada uno de nuestros casos de uso.
    \\Por ejemplo, si un usuario intenta acceder a una consulta la cual solo se le permite a los técnicos, gracias a poder identificar el id del usuario en base a su token podremos denegar dicha consulta y que no se permita.
\end{tcolorbox}

\subsection{El middleware}
El middleware, como concepto, representa a todo software que se sitúa entre el software y las aplicaciones que corren sobre él. Este funciona como una capa de traducción que posibilita la comunicación y la administración de datos en aplicaciones distribuidas. En nuestro caso nuestra función no trabajará en si como un ``middleware'' pero si que será una capa intermedia que se irá ejecutando a medida que el usuario interactúe con nuestra API aportándonos la comprobación de la validez de su token y su id de usuario.
\\Dentro del middleware tendremos una única función que correrá en cada momento que el usuario acceda a uno de nuestros endpoints.
\\La implementación sería la siguiente:
\begin{verbatim}
    const jwt = require("jwt-simple");
    const moment = require("moment");

    const checkToken = (req, res, next) => {
    if (!req.headers['user_token'])
        return res.json({
            error: "You must include the header"
        });

    const token = req.headers['user_token'];
    let payload = null
    try {
        payload = jwt.decode(token, process.env.TOKEN_KEY);
    } catch (err) {
        return res.json({
            error: "Invalid token"
        });
    }

    if (moment().unix() > payload.expiresAt) {
        return res.json({ error: "Expired token" });
    };

    req.userId = payload.userId;

    next();
    };
\end{verbatim}
Dentro de esta función realizamos 3 comprobaciones.

\subsubsection{Comprobación de los headers}
Nuestro token irá dentro del encabezado de las solicitudes que hagamos a la API. En concreto con la key ``user\_token''. Si no se incluye este encabezado no podríamos continuar con la comprobación por lo que se devuelve como respuesta al cliente \textit{You must include the header}.

\subsubsection{Decodificación del payload}
Luego de la comprobación de que haya ``algo'' al menos dentro de nuestro header procedemos a llamar a nuestro plugin de jwt y preguntarle si tiene un payload almacenado con la clave.
\\En el caso de que no pueda identificarlo, es decir, que no sea válido, obtendremos como respuesta en nuestro sitio web el siguiente mensaje: \textit{Invalid token}.

\subsubsection{Verificación de la validez}
Después del segundo paso podemos haber obtenido un payload pero tenemos que comprobar que este no haya expirado. Es decir, accedemos a su variables ``expiresAt''. En el caso de que lo haya hecho devolerá un error como respuesta con el siguiente mensaje: \textit{Expired token}.
\vspace{\baselineskip}
\\Incorporamos el user id a nuestra solicitud y con esto ya tendríamos implementado nuestro middleware.

\subsection{¿Cómo añadimos el proceso de verificación a cada consulta?}
Gracias a haber hecho nuestro código de forma estructurada y haber distinguido en servicios y rutas con solo añadir una línea a nuestro campo de rutas hará que podamos añadir este paso de verificación intermedio.
\\Primero importaremos nuestro fichero ``middleware'' y luego lo llamaremos en el código con la siguiente función:
\begin{verbatim}
    router.use(middleware.checkToken);
\end{verbatim}

\begin{tcolorbox}
    [colback=green!5!white,colframe=green!75!black,fonttitle=\bfseries,title=¿Cómo iniciamos sesión si no tenemos un token?]
    La respuesta es muy sencilla y va en relación a la lógica de nuestro archivo de rutas. Al entrar una petición a uno de nuestros endpoints lo que ocurre es que lo hace en forma de barrido en nuestros ficheros. Es decir que hasta que no llegue a la línea de código de antes no se habrá hecho la comprobación.
    \\Por lo tanto la solución es que dentro del fichero donde se realice el login y las demás acciones del usuario. Se coloque este primero en la parte de arriba, en medio nuestra comprobación y abajo el resto de consultas que también podemos hacer.
\end{tcolorbox}

\subsection{AuthGuard}
Aunque esta sea la parte final de la primera sección en verdad es el último apartado que estoy redactando de este capítulo, ya que ha sido el más difícil de implementar por la adquisición de nuevos conceptos que antes no conocía.
\\AuthGuard es un ``comprobador de usuarios''. Es decir, comprueba que estés logeado cogiendo tu token y mandándolo a la API, si esta no devuelve respuesta o lo hace con un \textit{null} el AuthGuard nos comunicaría que el usuario no está logeado.
\\Angular nos brinda la posibilidad de poder realizar una autenticación dentro del sistema de rutas de la aplicación. Es decir, dependiendo de a qué sitios quiera acceder de la aplicación puedo implementar unas medidas de seguridad u otras.
\\Esto lo consigo mediante la adición del parámetro \textbf{canActivate} y \textbf{canActivateChild}:
\begin{verbatim}
    path: '', component: MainComponent, 
    canActivate: [AuthGuardService],
    canActivateChild: [AuthGuardService],
    children: [
      { path: 'dashboard', component: DashboardComponent },
      {
        path: 'add-object', component: AddObjectComponent,
        children: [
            .
            .
            .
\end{verbatim}
canActivate y canActivateChild son dos interfaces que podemos implementar en un servicio de Angular. Estas dos interfaces nos van a implementar dos funciones de respectivo nombre y nos devolverán un booleano.
\\Este booleano, verdadero o falso, le dirá al sitio web si entro a la ruta que esté solicitando (en caso de ser verdadero) o si no lo hago (en caso de ser falso).
\\El problema que me han supuesto estas interfaces es que la implementación tenía que realizarla de forma asíncrona, asincronía de consultas que he utilizado en la API Rest pero que no había utilizado en el sitio web.
\\Gracias a este retraso que me ha llevado poder asegurar las rutas de la aplicación he conocido los Resolvers, los cuales son unos servicios que podemos implementar en documento de rutas cuando necesitemos recabar una información antes de inicializar el componente de Angular. El problema era que la inicialización del componente de Angular no conllevaba la inicialización del autenticador de ruta, servicio que se ejecutaba antes. Por lo que estuve dándole vueltas bastantes horas hasta que me di cuenta del fallo de concepto que había cometido.
\\Después descubrí los \textit{Observables} y las \textit{Promises}.

\subsubsection{Observable}
\begin{itemize}
    \item Es una implementación para eventos que conlleven una carga continua a lo largo del tiempo. Por ejemplo la reproducción de un vídeo.
    \item Tiene atributos que permiten realizar nuevamente solicitudes que han devuelto un error o de las que se han perdido información.
    \item Pueden solicitar datos en varias pipelines al mismo tiempo.
\end{itemize}

\subsubsection{Promise}
\begin{itemize}
    \item Una promise puede manejar solamente un elemento.
    \item Devuelve solo un único valor.
    \item Puede manejar también errores aunque sin un control exhaustivo como un Observable.
\end{itemize}

Cuando aprendí las diferencias entre estos dos elementos supe que tenía que utilizar una promise.
\\El segundo contatiempo y el más largo a mi parecer es que creía que la interfaz de canActivate y canActivateChild únicamente podían devolver un valor booleano. Pero también pueden devolver una Promise del tipo booleana por lo que de esa forma el problema de la asincronía ya estaba resuelto.
\\Nuestro AuthGuard implementaría la siguiente función:
\begin{verbatim}
    checkLoginPromise(): Promise<boolean> {
        const promise = new Promise<boolean>((resolve, reject) => {
        this.loginS.getUser()
            .toPromise()
            .then((res: any) => {
                // Success
                this.usuario = res;
                resolve(true);
            },
            err => {
                // Error
                this.logout();
                reject(false);
            }
            );
        });
        return promise;
    }
\end{verbatim}
Podemos comprobar que los dos valores que nos puede devolver la promesa son verdadero o falso. En caso de que sea verdadero el usuario quedará cargado en el sitio web para poder gestionar algunos estilos que requieren sus datos dentro de ella.
\\Y por último tendríamos los dos métodos canActivate y canActivateChild:
\begin{verbatim}
    canActivateChild(): Promise<boolean> {
        return this.checkLoginPromise();
    }

    canActivate(): Promise<boolean> {
        return this.checkLoginPromise();
    }
\end{verbatim}



